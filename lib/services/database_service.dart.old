import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';

/// Database service for storing trading logs and order history
///
/// Provides persistent storage for:
/// - Trade logs (max 100 displayed, all stored)
/// - Order history with technical indicators
class DatabaseService {
  static final DatabaseService _instance = DatabaseService._internal();
  static Database? _database;

  factory DatabaseService() => _instance;

  DatabaseService._internal();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  Future<Database> _initDatabase() async {
    final Directory documentsDirectory = await getApplicationDocumentsDirectory();
    final String path = join(documentsDirectory.path, 'trading.db');

    return await openDatabase(
      path,
      version: 3,
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> _onCreate(Database db, int version) async {
    // Trade logs table
    await db.execute('''
      CREATE TABLE trade_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp INTEGER NOT NULL,
        type TEXT NOT NULL,
        message TEXT NOT NULL,
        symbol TEXT NOT NULL,
        synced INTEGER NOT NULL DEFAULT 0
      )
    ''');

    // Order history table
    await db.execute('''
      CREATE TABLE order_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp INTEGER NOT NULL,
        symbol TEXT NOT NULL,
        side TEXT NOT NULL,
        entry_price REAL NOT NULL,
        quantity REAL NOT NULL,
        leverage INTEGER NOT NULL,
        tp_price REAL NOT NULL,
        sl_price REAL NOT NULL,
        signal_strength REAL NOT NULL,
        rsi6 REAL NOT NULL,
        rsi14 REAL NOT NULL,
        ema9 REAL NOT NULL,
        ema21 REAL NOT NULL,
        volume REAL NOT NULL,
        volume_ma5 REAL NOT NULL,
        bollinger_upper REAL,
        bollinger_middle REAL,
        bollinger_lower REAL,
        synced INTEGER NOT NULL DEFAULT 0
      )
    ''');

    // Create indexes for faster queries
    await db.execute('CREATE INDEX idx_trade_logs_timestamp ON trade_logs(timestamp DESC)');
    await db.execute('CREATE INDEX idx_order_history_timestamp ON order_history(timestamp DESC)');
    await db.execute('CREATE INDEX idx_trade_logs_synced ON trade_logs(synced)');
    await db.execute('CREATE INDEX idx_order_history_synced ON order_history(synced)');

    // Coinone trade logs table
    await db.execute('''
      CREATE TABLE coinone_trade_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp INTEGER NOT NULL,
        type TEXT NOT NULL,
        message TEXT NOT NULL,
        symbol TEXT NOT NULL,
        synced INTEGER NOT NULL DEFAULT 0
      )
    ''');

    // Coinone order history table
    await db.execute('''
      CREATE TABLE coinone_order_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp INTEGER NOT NULL,
        symbol TEXT NOT NULL,
        side TEXT NOT NULL,
        price REAL NOT NULL,
        quantity REAL NOT NULL,
        user_order_id TEXT NOT NULL,
        order_id TEXT,
        status TEXT NOT NULL,
        bollinger_upper REAL,
        bollinger_middle REAL,
        bollinger_lower REAL,
        synced INTEGER NOT NULL DEFAULT 0
      )
    ''');

    // Coinone withdrawal addresses cache
    await db.execute('''
      CREATE TABLE coinone_withdrawal_addresses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        coin TEXT NOT NULL,
        address TEXT NOT NULL,
        label TEXT,
        last_used INTEGER NOT NULL,
        UNIQUE(coin, address)
      )
    ''');

    // Create indexes for Coinone tables
    await db.execute('CREATE INDEX idx_coinone_trade_logs_timestamp ON coinone_trade_logs(timestamp DESC)');
    await db.execute('CREATE INDEX idx_coinone_order_history_timestamp ON coinone_order_history(timestamp DESC)');
    await db.execute('CREATE INDEX idx_coinone_trade_logs_synced ON coinone_trade_logs(synced)');
    await db.execute('CREATE INDEX idx_coinone_order_history_synced ON coinone_order_history(synced)');
    await db.execute('CREATE INDEX idx_coinone_withdrawal_last_used ON coinone_withdrawal_addresses(last_used DESC)');
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    if (oldVersion < 2) {
      // Add synced column to trade_logs
      await db.execute('ALTER TABLE trade_logs ADD COLUMN synced INTEGER NOT NULL DEFAULT 0');

      // Add synced column to order_history
      await db.execute('ALTER TABLE order_history ADD COLUMN synced INTEGER NOT NULL DEFAULT 0');

      // Create indexes for synced column
      await db.execute('CREATE INDEX idx_trade_logs_synced ON trade_logs(synced)');
      await db.execute('CREATE INDEX idx_order_history_synced ON order_history(synced)');
    }

    if (oldVersion < 3) {
      // Create Coinone trade logs table
      await db.execute('''
        CREATE TABLE coinone_trade_logs (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          timestamp INTEGER NOT NULL,
          type TEXT NOT NULL,
          message TEXT NOT NULL,
          symbol TEXT NOT NULL,
          synced INTEGER NOT NULL DEFAULT 0
        )
      ''');

      // Create Coinone order history table
      await db.execute('''
        CREATE TABLE coinone_order_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          timestamp INTEGER NOT NULL,
          symbol TEXT NOT NULL,
          side TEXT NOT NULL,
          price REAL NOT NULL,
          quantity REAL NOT NULL,
          user_order_id TEXT NOT NULL,
          order_id TEXT,
          status TEXT NOT NULL,
          bollinger_upper REAL,
          bollinger_middle REAL,
          bollinger_lower REAL,
          synced INTEGER NOT NULL DEFAULT 0
        )
      ''');

      // Create Coinone withdrawal addresses table
      await db.execute('''
        CREATE TABLE coinone_withdrawal_addresses (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          coin TEXT NOT NULL,
          address TEXT NOT NULL,
          label TEXT,
          last_used INTEGER NOT NULL,
          UNIQUE(coin, address)
        )
      ''');

      // Create indexes for Coinone tables
      await db.execute('CREATE INDEX idx_coinone_trade_logs_timestamp ON coinone_trade_logs(timestamp DESC)');
      await db.execute('CREATE INDEX idx_coinone_order_history_timestamp ON coinone_order_history(timestamp DESC)');
      await db.execute('CREATE INDEX idx_coinone_trade_logs_synced ON coinone_trade_logs(synced)');
      await db.execute('CREATE INDEX idx_coinone_order_history_synced ON coinone_order_history(synced)');
      await db.execute('CREATE INDEX idx_coinone_withdrawal_last_used ON coinone_withdrawal_addresses(last_used DESC)');
    }
  }

  /// Inserts a trade log entry
  Future<int> insertTradeLog({
    required String type,
    required String message,
    required String symbol,
  }) async {
    final db = await database;
    return await db.insert('trade_logs', {
      'timestamp': DateTime.now().millisecondsSinceEpoch,
      'type': type,
      'message': message,
      'symbol': symbol,
    });
  }

  /// Gets recent trade logs (default: 100)
  Future<List<Map<String, dynamic>>> getRecentTradeLogs({
    int limit = 100,
    String? symbol,
  }) async {
    final db = await database;
    if (symbol != null) {
      return await db.query(
        'trade_logs',
        where: 'symbol = ?',
        whereArgs: [symbol],
        orderBy: 'timestamp DESC',
        limit: limit,
      );
    } else {
      return await db.query(
        'trade_logs',
        orderBy: 'timestamp DESC',
        limit: limit,
      );
    }
  }

  /// Inserts an order history entry
  Future<int> insertOrderHistory({
    required String symbol,
    required String side,
    required double entryPrice,
    required double quantity,
    required int leverage,
    required double tpPrice,
    required double slPrice,
    required double signalStrength,
    required double rsi6,
    required double rsi14,
    required double ema9,
    required double ema21,
    required double volume,
    required double volumeMa5,
    double? bollingerUpper,
    double? bollingerMiddle,
    double? bollingerLower,
  }) async {
    final db = await database;
    return await db.insert('order_history', {
      'timestamp': DateTime.now().millisecondsSinceEpoch,
      'symbol': symbol,
      'side': side,
      'entry_price': entryPrice,
      'quantity': quantity,
      'leverage': leverage,
      'tp_price': tpPrice,
      'sl_price': slPrice,
      'signal_strength': signalStrength,
      'rsi6': rsi6,
      'rsi14': rsi14,
      'ema9': ema9,
      'ema21': ema21,
      'volume': volume,
      'volume_ma5': volumeMa5,
      'bollinger_upper': bollingerUpper,
      'bollinger_middle': bollingerMiddle,
      'bollinger_lower': bollingerLower,
    });
  }

  /// Gets order history (default: 100)
  Future<List<Map<String, dynamic>>> getOrderHistory({
    int limit = 100,
    String? symbol,
  }) async {
    final db = await database;
    if (symbol != null) {
      return await db.query(
        'order_history',
        where: 'symbol = ?',
        whereArgs: [symbol],
        orderBy: 'timestamp DESC',
        limit: limit,
      );
    } else {
      return await db.query(
        'order_history',
        orderBy: 'timestamp DESC',
        limit: limit,
      );
    }
  }

  /// Deletes old trade logs (keeps last N entries)
  Future<int> cleanupOldTradeLogs({int keep = 1000}) async {
    final db = await database;
    // Get the timestamp of the Nth newest log
    final List<Map<String, dynamic>> result = await db.query(
      'trade_logs',
      columns: ['timestamp'],
      orderBy: 'timestamp DESC',
      limit: 1,
      offset: keep,
    );

    if (result.isEmpty) return 0;

    final int cutoffTimestamp = result.first['timestamp'] as int;
    return await db.delete(
      'trade_logs',
      where: 'timestamp < ?',
      whereArgs: [cutoffTimestamp],
    );
  }

  /// Deletes old order history (keeps last N entries)
  Future<int> cleanupOldOrderHistory({int keep = 1000}) async {
    final db = await database;
    // Get the timestamp of the Nth newest order
    final List<Map<String, dynamic>> result = await db.query(
      'order_history',
      columns: ['timestamp'],
      orderBy: 'timestamp DESC',
      limit: 1,
      offset: keep,
    );

    if (result.isEmpty) return 0;

    final int cutoffTimestamp = result.first['timestamp'] as int;
    return await db.delete(
      'order_history',
      where: 'timestamp < ?',
      whereArgs: [cutoffTimestamp],
    );
  }

  /// Deletes all trade logs
  Future<int> deleteAllTradeLogs() async {
    final db = await database;
    return await db.delete('trade_logs');
  }

  /// Deletes all order history
  Future<int> deleteAllOrderHistory() async {
    final db = await database;
    return await db.delete('order_history');
  }

  /// Deletes all data (trade logs and order history)
  Future<void> clearAllData() async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('trade_logs');
      await txn.delete('order_history');
    });
  }

  /// Closes the database
  Future<void> close() async {
    final db = await database;
    await db.close();
  }

  // ============================================================================
  // Sync-related methods (for future MongoDB integration)
  // ============================================================================

  /// Gets unsynced trade logs
  Future<List<Map<String, dynamic>>> getUnsyncedTradeLogs({int? limit}) async {
    final db = await database;
    return await db.query(
      'trade_logs',
      where: 'synced = ?',
      whereArgs: [0],
      orderBy: 'timestamp ASC',
      limit: limit,
    );
  }

  /// Gets unsynced order history
  Future<List<Map<String, dynamic>>> getUnsyncedOrderHistory({int? limit}) async {
    final db = await database;
    return await db.query(
      'order_history',
      where: 'synced = ?',
      whereArgs: [0],
      orderBy: 'timestamp ASC',
      limit: limit,
    );
  }

  /// Marks trade logs as synced
  Future<int> markTradeLogsAsSynced(List<int> ids) async {
    final db = await database;
    return await db.update(
      'trade_logs',
      {'synced': 1},
      where: 'id IN (${ids.map((_) => '?').join(', ')})',
      whereArgs: ids,
    );
  }

  /// Marks order history as synced
  Future<int> markOrderHistoryAsSynced(List<int> ids) async {
    final db = await database;
    return await db.update(
      'order_history',
      {'synced': 1},
      where: 'id IN (${ids.map((_) => '?').join(', ')})',
      whereArgs: ids,
    );
  }

  /// Gets count of unsynced trade logs
  Future<int> getUnsyncedTradeLogsCount() async {
    final db = await database;
    final result = await db.rawQuery(
      'SELECT COUNT(*) as count FROM trade_logs WHERE synced = 0'
    );
    return Sqflite.firstIntValue(result) ?? 0;
  }

  /// Gets count of unsynced order history
  Future<int> getUnsyncedOrderHistoryCount() async {
    final db = await database;
    final result = await db.rawQuery(
      'SELECT COUNT(*) as count FROM order_history WHERE synced = 0'
    );
    return Sqflite.firstIntValue(result) ?? 0;
  }

  /// Gets total synced records count
  Future<Map<String, int>> getSyncStats() async {
    final db = await database;

    final tradeLogsTotal = await db.rawQuery('SELECT COUNT(*) as count FROM trade_logs');
    final tradeLogsSynced = await db.rawQuery('SELECT COUNT(*) as count FROM trade_logs WHERE synced = 1');
    final orderHistoryTotal = await db.rawQuery('SELECT COUNT(*) as count FROM order_history');
    final orderHistorySynced = await db.rawQuery('SELECT COUNT(*) as count FROM order_history WHERE synced = 1');

    return {
      'tradeLogsTotal': Sqflite.firstIntValue(tradeLogsTotal) ?? 0,
      'tradeLogsSynced': Sqflite.firstIntValue(tradeLogsSynced) ?? 0,
      'tradeLogsUnsynced': (Sqflite.firstIntValue(tradeLogsTotal) ?? 0) - (Sqflite.firstIntValue(tradeLogsSynced) ?? 0),
      'orderHistoryTotal': Sqflite.firstIntValue(orderHistoryTotal) ?? 0,
      'orderHistorySynced': Sqflite.firstIntValue(orderHistorySynced) ?? 0,
      'orderHistoryUnsynced': (Sqflite.firstIntValue(orderHistoryTotal) ?? 0) - (Sqflite.firstIntValue(orderHistorySynced) ?? 0),
    };
  }

  // ============================================================================
  // Coinone-specific methods
  // ============================================================================

  /// Inserts a Coinone trade log entry
  Future<int> insertCoinoneTradeLog({
    required String type,
    required String message,
    required String symbol,
  }) async {
    final db = await database;
    return await db.insert('coinone_trade_logs', {
      'timestamp': DateTime.now().millisecondsSinceEpoch,
      'type': type,
      'message': message,
      'symbol': symbol,
    });
  }

  /// Gets recent Coinone trade logs
  Future<List<Map<String, dynamic>>> getCoinoneTradeLogs({
    int limit = 100,
    String? symbol,
  }) async {
    final db = await database;
    if (symbol != null) {
      return await db.query(
        'coinone_trade_logs',
        where: 'symbol = ?',
        whereArgs: [symbol],
        orderBy: 'timestamp DESC',
        limit: limit,
      );
    } else {
      return await db.query(
        'coinone_trade_logs',
        orderBy: 'timestamp DESC',
        limit: limit,
      );
    }
  }

  /// Inserts a Coinone order history entry
  Future<int> insertCoinoneOrderHistory({
    required String symbol,
    required String side,
    required double price,
    required double quantity,
    required String userOrderId,
    String? orderId,
    required String status,
    double? bollingerUpper,
    double? bollingerMiddle,
    double? bollingerLower,
  }) async {
    final db = await database;
    return await db.insert('coinone_order_history', {
      'timestamp': DateTime.now().millisecondsSinceEpoch,
      'symbol': symbol,
      'side': side,
      'price': price,
      'quantity': quantity,
      'user_order_id': userOrderId,
      'order_id': orderId,
      'status': status,
      'bollinger_upper': bollingerUpper,
      'bollinger_middle': bollingerMiddle,
      'bollinger_lower': bollingerLower,
    });
  }

  /// Gets Coinone order history
  Future<List<Map<String, dynamic>>> getCoinoneOrderHistory({
    int limit = 100,
    String? symbol,
  }) async {
    final db = await database;
    if (symbol != null) {
      return await db.query(
        'coinone_order_history',
        where: 'symbol = ?',
        whereArgs: [symbol],
        orderBy: 'timestamp DESC',
        limit: limit,
      );
    } else {
      return await db.query(
        'coinone_order_history',
        orderBy: 'timestamp DESC',
        limit: limit,
      );
    }
  }

  /// Save or update a withdrawal address
  Future<int> saveCoinoneWithdrawalAddress({
    required String coin,
    required String address,
    String? label,
  }) async {
    final db = await database;
    return await db.insert(
      'coinone_withdrawal_addresses',
      {
        'coin': coin,
        'address': address,
        'label': label,
        'last_used': DateTime.now().millisecondsSinceEpoch,
      },
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  /// Get recent withdrawal addresses for a coin
  Future<List<Map<String, dynamic>>> getCoinoneWithdrawalAddresses({
    required String coin,
    int limit = 10,
  }) async {
    final db = await database;
    return await db.query(
      'coinone_withdrawal_addresses',
      where: 'coin = ?',
      whereArgs: [coin],
      orderBy: 'last_used DESC',
      limit: limit,
    );
  }

  /// Gets unsynced Coinone trade logs
  Future<List<Map<String, dynamic>>> getUnsyncedCoinoneTradeLogs({int? limit}) async {
    final db = await database;
    return await db.query(
      'coinone_trade_logs',
      where: 'synced = ?',
      whereArgs: [0],
      orderBy: 'timestamp ASC',
      limit: limit,
    );
  }

  /// Gets unsynced Coinone order history
  Future<List<Map<String, dynamic>>> getUnsyncedCoinoneOrderHistory({int? limit}) async {
    final db = await database;
    return await db.query(
      'coinone_order_history',
      where: 'synced = ?',
      whereArgs: [0],
      orderBy: 'timestamp ASC',
      limit: limit,
    );
  }

  /// Marks Coinone trade logs as synced
  Future<int> markCoinoneTradeLogsAsSynced(List<int> ids) async {
    final db = await database;
    return await db.update(
      'coinone_trade_logs',
      {'synced': 1},
      where: 'id IN (${ids.map((_) => '?').join(', ')})',
      whereArgs: ids,
    );
  }

  /// Marks Coinone order history as synced
  Future<int> markCoinoneOrderHistoryAsSynced(List<int> ids) async {
    final db = await database;
    return await db.update(
      'coinone_order_history',
      {'synced': 1},
      where: 'id IN (${ids.map((_) => '?').join(', ')})',
      whereArgs: ids,
    );
  }

  /// Deletes all Coinone data
  Future<void> clearAllCoinoneData() async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('coinone_trade_logs');
      await txn.delete('coinone_order_history');
      await txn.delete('coinone_withdrawal_addresses');
    });
  }
}
