import 'package:bybit_scalping_bot/models/market_condition.dart';
import 'package:bybit_scalping_bot/utils/technical_indicators.dart';
import 'package:bybit_scalping_bot/utils/logger.dart';

/// Trading signal type
enum SignalType {
  long,
  short,
  none,
}

/// Helper function to convert SignalType to string (avoids .name compatibility issues)
String signalTypeToString(SignalType type) {
  switch (type) {
    case SignalType.long:
      return 'long';
    case SignalType.short:
      return 'short';
    case SignalType.none:
      return 'none';
  }
}

/// Strategy configuration for a specific market condition
class StrategyConfig {
  final double takeProfitPercent; // TP as percentage (e.g., 0.008 = 0.8%)
  final double stopLossPercent; // SL as percentage (e.g., 0.004 = 0.4%)
  final int recommendedLeverage;
  final bool useTrailingStop;
  final double trailingStopTrigger; // Profit percentage to activate trailing
  final String description;

  StrategyConfig({
    required this.takeProfitPercent,
    required this.stopLossPercent,
    required this.recommendedLeverage,
    required this.useTrailingStop,
    required this.trailingStopTrigger,
    required this.description,
  });

  /// Get TP/SL in ROE percentage (considering leverage)
  double get takeProfitROE => takeProfitPercent * recommendedLeverage * 100;
  double get stopLossROE => stopLossPercent * recommendedLeverage * 100;
}

/// Trading signal with entry details
class TradingSignal {
  final SignalType type;
  final double confidence; // 0.0 to 1.0
  final String reasoning;
  final double? entryPrice; // Suggested entry price
  final double? takeProfitPrice;
  final double? stopLossPrice;
  final StrategyConfig strategyConfig;

  TradingSignal({
    required this.type,
    required this.confidence,
    required this.reasoning,
    this.entryPrice,
    this.takeProfitPrice,
    this.stopLossPrice,
    required this.strategyConfig,
  });

  bool get hasSignal => type != SignalType.none;
}

/// Adaptive trading strategy
///
/// Provides market-condition-specific trading strategies:
/// - Entry signal detection
/// - TP/SL calculation
/// - Position sizing recommendation
class AdaptiveStrategy {
  /// Get strategy configuration for a market condition
  static StrategyConfig getStrategyConfig(MarketCondition condition) {
    switch (condition) {
      case MarketCondition.extremeBullish:
        return StrategyConfig(
          takeProfitPercent: 0.012, // 1.2%
          stopLossPercent: 0.004, // 0.4%
          recommendedLeverage: 5,
          useTrailingStop: true,
          trailingStopTrigger: 0.005, // Activate at +0.5%
          description: 'Band Walking Ï∂îÏÑ∏ Ï∂îÏ¢Ö (Î°± Ï†ÑÏö©)',
        );

      case MarketCondition.strongBullish:
        return StrategyConfig(
          takeProfitPercent: 0.010, // 1.0%
          stopLossPercent: 0.004, // 0.4%
          recommendedLeverage: 8,
          useTrailingStop: false,
          trailingStopTrigger: 0.006,
          description: 'Í∞ïÏÑ∏Ïû• Ï∂îÏÑ∏ Ï∂îÏ¢Ö (Î°± ÏúÑÏ£º)',
        );

      case MarketCondition.weakBullish:
        return StrategyConfig(
          takeProfitPercent: 0.008, // 0.8%
          stopLossPercent: 0.004, // 0.4%
          recommendedLeverage: 10,
          useTrailingStop: false,
          trailingStopTrigger: 0.006,
          description: 'ÏïΩÌïú Í∞ïÏÑ∏Ïû• ÌèâÍ∑†ÌöåÍ∑Ä',
        );

      case MarketCondition.ranging:
        return StrategyConfig(
          takeProfitPercent: 0.005, // 0.5%
          stopLossPercent: 0.003, // 0.3%
          recommendedLeverage: 15,
          useTrailingStop: false,
          trailingStopTrigger: 0.004,
          description: 'Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú Ïó≠Ï∂îÏÑ∏',
        );

      case MarketCondition.weakBearish:
        return StrategyConfig(
          takeProfitPercent: 0.008, // 0.8%
          stopLossPercent: 0.004, // 0.4%
          recommendedLeverage: 10,
          useTrailingStop: false,
          trailingStopTrigger: 0.006,
          description: 'ÏïΩÌïú ÏïΩÏÑ∏Ïû• ÌèâÍ∑†ÌöåÍ∑Ä',
        );

      case MarketCondition.strongBearish:
        return StrategyConfig(
          takeProfitPercent: 0.010, // 1.0%
          stopLossPercent: 0.004, // 0.4%
          recommendedLeverage: 8,
          useTrailingStop: false,
          trailingStopTrigger: 0.006,
          description: 'ÏïΩÏÑ∏Ïû• Ï∂îÏÑ∏ Ï∂îÏ¢Ö (Ïàè ÏúÑÏ£º)',
        );

      case MarketCondition.extremeBearish:
        return StrategyConfig(
          takeProfitPercent: 0.012, // 1.2%
          stopLossPercent: 0.004, // 0.4%
          recommendedLeverage: 5,
          useTrailingStop: true,
          trailingStopTrigger: 0.005,
          description: 'Band Walking Ï∂îÏÑ∏ Ï∂îÏ¢Ö (Ïàè Ï†ÑÏö©)',
        );
    }
  }

  /// Analyze and generate trading signal based on market condition
  static TradingSignal analyzeSignal({
    required MarketCondition condition,
    required List<double> closePrices,
    required List<double> volumes,
    required double currentPrice,
  }) {
    Logger.debug('AdaptiveStrategy: Analyzing signal for ${condition.displayName}');

    final strategyConfig = getStrategyConfig(condition);

    // PRIORITY 1: Check for breakout signals first (strongest signals)
    // Breakouts only in extreme market conditions
    final breakoutSignal = _analyzeBreakoutSignal(
      condition: condition,
      closePrices: closePrices,
      currentPrice: currentPrice,
      strategyConfig: strategyConfig,
    );

    if (breakoutSignal.hasSignal) {
      Logger.debug('üöÄ BREAKOUT DETECTED: ${breakoutSignal.reasoning}');
      return breakoutSignal;
    }

    // PRIORITY 2: Condition-based strategies
    switch (condition) {
      case MarketCondition.extremeBullish:
        return _analyzeExtremeBullishSignal(
          closePrices: closePrices,
          volumes: volumes,
          currentPrice: currentPrice,
          strategyConfig: strategyConfig,
        );

      case MarketCondition.strongBullish:
      case MarketCondition.weakBullish:
        return _analyzeBullishSignal(
          closePrices: closePrices,
          volumes: volumes,
          currentPrice: currentPrice,
          strategyConfig: strategyConfig,
        );

      case MarketCondition.ranging:
        return _analyzeRangingSignal(
          closePrices: closePrices,
          volumes: volumes,
          currentPrice: currentPrice,
          strategyConfig: strategyConfig,
        );

      case MarketCondition.weakBearish:
      case MarketCondition.strongBearish:
        return _analyzeBearishSignal(
          closePrices: closePrices,
          volumes: volumes,
          currentPrice: currentPrice,
          strategyConfig: strategyConfig,
        );

      case MarketCondition.extremeBearish:
        return _analyzeExtremeBearishSignal(
          closePrices: closePrices,
          volumes: volumes,
          currentPrice: currentPrice,
          strategyConfig: strategyConfig,
        );
    }
  }

  /// Extreme Bullish Strategy: Long on RSI pullback
  static TradingSignal _analyzeExtremeBullishSignal({
    required List<double> closePrices,
    required List<double> volumes,
    required double currentPrice,
    required StrategyConfig strategyConfig,
  }) {
    final rsi = calculateRSISeries(closePrices, 14);
    if (rsi.isEmpty) {
      return TradingSignal(
        type: SignalType.none,
        confidence: 0.0,
        reasoning: 'RSI Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±',
        strategyConfig: strategyConfig,
      );
    }

    final currentRSI = rsi.last;
    Logger.debug('üìà [Í∑πÍ∞ïÏÑ∏] RSI(14) = ${currentRSI.toStringAsFixed(2)} (ÏµúÍ∑º5Í∞ú: ${rsi.length >= 5 ? rsi.sublist(rsi.length - 5).map((r) => r.toStringAsFixed(1)).join(", ") : rsi.map((r) => r.toStringAsFixed(1)).join(", ")})');
    final bb = calculateBollingerBandsDefault(closePrices);

    // Entry: RSI pullback from 70+ to 50-65 range
    if (currentRSI >= 50 && currentRSI <= 65) {
      // Check if RSI was recently above 70 (within last 5 candles)
      final recentRSI = rsi.length >= 5 ? rsi.sublist(rsi.length - 5) : rsi;
      final wasOverbought = recentRSI.any((r) => r > 70);

      if (wasOverbought) {
        final confidence = 0.7 + (65 - currentRSI) / 100; // Higher confidence closer to 50

        return TradingSignal(
          type: SignalType.long,
          confidence: confidence.clamp(0.0, 1.0),
          reasoning: 'RSI Ï°∞Ï†ï ÌõÑ Ïû¨ÏÉÅÏäπ Ïã†Ìò∏ (RSI: ${currentRSI.toStringAsFixed(1)})',
          entryPrice: currentPrice,
          takeProfitPrice: currentPrice * (1 + strategyConfig.takeProfitPercent),
          stopLossPrice: currentPrice * (1 - strategyConfig.stopLossPercent),
          strategyConfig: strategyConfig,
        );
      }
    }

    return TradingSignal(
      type: SignalType.none,
      confidence: 0.0,
      reasoning: 'RSI Ï°∞Ï†ï ÎåÄÍ∏∞ Ï§ë (ÌòÑÏû¨ RSI: ${currentRSI.toStringAsFixed(1)})',
      strategyConfig: strategyConfig,
    );
  }

  /// Bullish Strategy: Long on dips with RSI 45-55
  static TradingSignal _analyzeBullishSignal({
    required List<double> closePrices,
    required List<double> volumes,
    required double currentPrice,
    required StrategyConfig strategyConfig,
  }) {
    final rsi = calculateRSISeries(closePrices, 14);
    if (rsi.isEmpty) {
      return TradingSignal(
        type: SignalType.none,
        confidence: 0.0,
        reasoning: 'RSI Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±',
        strategyConfig: strategyConfig,
      );
    }

    final currentRSI = rsi.last;
    Logger.debug('üìä [Í∞ïÏÑ∏] RSI(14) = ${currentRSI.toStringAsFixed(2)} (ÏµúÍ∑º5Í∞ú: ${rsi.length >= 5 ? rsi.sublist(rsi.length - 5).map((r) => r.toStringAsFixed(1)).join(", ") : rsi.map((r) => r.toStringAsFixed(1)).join(", ")})');
    final ema9 = calculateEMASeries(closePrices, 9);

    // Entry: RSI pullback to 45-55, or bounce off EMA9
    if (currentRSI >= 45 && currentRSI <= 55) {
      final confidence = 0.6 + (55 - currentRSI) / 50; // Higher confidence closer to 45

      return TradingSignal(
        type: SignalType.long,
        confidence: confidence.clamp(0.0, 1.0),
        reasoning: 'ÌíÄÎ∞± ÏßÑÏûÖ Ïã†Ìò∏ (RSI: ${currentRSI.toStringAsFixed(1)})',
        entryPrice: currentPrice,
        takeProfitPrice: currentPrice * (1 + strategyConfig.takeProfitPercent),
        stopLossPrice: currentPrice * (1 - strategyConfig.stopLossPercent),
        strategyConfig: strategyConfig,
      );
    }

    return TradingSignal(
      type: SignalType.none,
      confidence: 0.0,
      reasoning: 'RSI ÌíÄÎ∞± ÎåÄÍ∏∞ (ÌòÑÏû¨: ${currentRSI.toStringAsFixed(1)})',
      strategyConfig: strategyConfig,
    );
  }

  /// Ranging Strategy: Bollinger Band mean reversion
  static TradingSignal _analyzeRangingSignal({
    required List<double> closePrices,
    required List<double> volumes,
    required double currentPrice,
    required StrategyConfig strategyConfig,
  }) {
    final rsi = calculateRSISeries(closePrices, 14);
    final bb = calculateBollingerBandsDefault(closePrices);

    if (rsi.isEmpty) {
      return TradingSignal(
        type: SignalType.none,
        confidence: 0.0,
        reasoning: 'RSI Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±',
        strategyConfig: strategyConfig,
      );
    }

    final currentRSI = rsi.last;
    Logger.debug('‚ÜîÔ∏è  [Ìö°Î≥¥] RSI(14) = ${currentRSI.toStringAsFixed(2)} (ÏµúÍ∑º5Í∞ú: ${rsi.length >= 5 ? rsi.sublist(rsi.length - 5).map((r) => r.toStringAsFixed(1)).join(", ") : rsi.map((r) => r.toStringAsFixed(1)).join(", ")})');

    // Long signal: Price near lower band + RSI < 35
    if (currentPrice <= bb.lower * 1.005 && currentRSI < 35) {
      return TradingSignal(
        type: SignalType.long,
        confidence: 0.75,
        reasoning: 'Î≥ºÎ¶∞Ï†Ä ÌïòÎã® + Í≥ºÎß§ÎèÑ (RSI: ${currentRSI.toStringAsFixed(1)})',
        entryPrice: currentPrice,
        takeProfitPrice: currentPrice * (1 + strategyConfig.takeProfitPercent),
        stopLossPrice: currentPrice * (1 - strategyConfig.stopLossPercent),
        strategyConfig: strategyConfig,
      );
    }

    // Short signal: Price near upper band + RSI > 65
    if (currentPrice >= bb.upper * 0.995 && currentRSI > 65) {
      return TradingSignal(
        type: SignalType.short,
        confidence: 0.75,
        reasoning: 'Î≥ºÎ¶∞Ï†Ä ÏÉÅÎã® + Í≥ºÎß§Ïàò (RSI: ${currentRSI.toStringAsFixed(1)})',
        entryPrice: currentPrice,
        takeProfitPrice: currentPrice * (1 - strategyConfig.takeProfitPercent),
        stopLossPrice: currentPrice * (1 + strategyConfig.stopLossPercent),
        strategyConfig: strategyConfig,
      );
    }

    return TradingSignal(
      type: SignalType.none,
      confidence: 0.0,
      reasoning: 'ÏßÑÏûÖ Ïã†Ìò∏ ÏóÜÏùå (RSI: ${currentRSI.toStringAsFixed(1)})',
      strategyConfig: strategyConfig,
    );
  }

  /// Bearish Strategy: Short on bounces with RSI 45-55
  static TradingSignal _analyzeBearishSignal({
    required List<double> closePrices,
    required List<double> volumes,
    required double currentPrice,
    required StrategyConfig strategyConfig,
  }) {
    final rsi = calculateRSISeries(closePrices, 14);
    if (rsi.isEmpty) {
      return TradingSignal(
        type: SignalType.none,
        confidence: 0.0,
        reasoning: 'RSI Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±',
        strategyConfig: strategyConfig,
      );
    }

    final currentRSI = rsi.last;
    Logger.debug('üìâ [ÏïΩÏÑ∏] RSI(14) = ${currentRSI.toStringAsFixed(2)} (ÏµúÍ∑º5Í∞ú: ${rsi.length >= 5 ? rsi.sublist(rsi.length - 5).map((r) => r.toStringAsFixed(1)).join(", ") : rsi.map((r) => r.toStringAsFixed(1)).join(", ")})');

    // Entry: RSI bounce to 45-55 range
    if (currentRSI >= 45 && currentRSI <= 55) {
      final confidence = 0.6 + (currentRSI - 45) / 50; // Higher confidence closer to 55

      return TradingSignal(
        type: SignalType.short,
        confidence: confidence.clamp(0.0, 1.0),
        reasoning: 'Î∞òÎì± Ïàè ÏßÑÏûÖ Ïã†Ìò∏ (RSI: ${currentRSI.toStringAsFixed(1)})',
        entryPrice: currentPrice,
        takeProfitPrice: currentPrice * (1 - strategyConfig.takeProfitPercent),
        stopLossPrice: currentPrice * (1 + strategyConfig.stopLossPercent),
        strategyConfig: strategyConfig,
      );
    }

    return TradingSignal(
      type: SignalType.none,
      confidence: 0.0,
      reasoning: 'RSI Î∞òÎì± ÎåÄÍ∏∞ (ÌòÑÏû¨: ${currentRSI.toStringAsFixed(1)})',
      strategyConfig: strategyConfig,
    );
  }

  /// Extreme Bearish Strategy: Short on RSI bounce
  static TradingSignal _analyzeExtremeBearishSignal({
    required List<double> closePrices,
    required List<double> volumes,
    required double currentPrice,
    required StrategyConfig strategyConfig,
  }) {
    final rsi = calculateRSISeries(closePrices, 14);
    if (rsi.isEmpty) {
      return TradingSignal(
        type: SignalType.none,
        confidence: 0.0,
        reasoning: 'RSI Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±',
        strategyConfig: strategyConfig,
      );
    }

    final currentRSI = rsi.last;
    Logger.debug('üìâüìâ [Í∑πÏïΩÏÑ∏] RSI(14) = ${currentRSI.toStringAsFixed(2)} (ÏµúÍ∑º5Í∞ú: ${rsi.length >= 5 ? rsi.sublist(rsi.length - 5).map((r) => r.toStringAsFixed(1)).join(", ") : rsi.map((r) => r.toStringAsFixed(1)).join(", ")})');

    // Entry: RSI bounce from 30- to 35-50 range
    if (currentRSI >= 35 && currentRSI <= 50) {
      // Check if RSI was recently below 30 (within last 5 candles)
      final recentRSI = rsi.length >= 5 ? rsi.sublist(rsi.length - 5) : rsi;
      final wasOversold = recentRSI.any((r) => r < 30);

      if (wasOversold) {
        final confidence = 0.7 + (currentRSI - 35) / 100;

        return TradingSignal(
          type: SignalType.short,
          confidence: confidence.clamp(0.0, 1.0),
          reasoning: 'RSI Î∞òÎì± ÌõÑ Ïû¨ÌïòÎùΩ Ïã†Ìò∏ (RSI: ${currentRSI.toStringAsFixed(1)})',
          entryPrice: currentPrice,
          takeProfitPrice: currentPrice * (1 - strategyConfig.takeProfitPercent),
          stopLossPrice: currentPrice * (1 + strategyConfig.stopLossPercent),
          strategyConfig: strategyConfig,
        );
      }
    }

    return TradingSignal(
      type: SignalType.none,
      confidence: 0.0,
      reasoning: 'RSI Î∞òÎì± ÎåÄÍ∏∞ Ï§ë (ÌòÑÏû¨ RSI: ${currentRSI.toStringAsFixed(1)})',
      strategyConfig: strategyConfig,
    );
  }

  // ============================================================================
  // BREAKOUT STRATEGY (Priority Signal - Extreme Markets Only)
  // ============================================================================

  /// Analyze breakout/breakdown signals for EXTREME market conditions only
  ///
  /// This strategy only activates in extreme bullish/bearish markets.
  ///
  /// Extreme Bullish Market (Í∞ïÌïú ÏÉÅÏäπ Î™®Î©òÌÖÄ):
  /// - RSI <= 75: LONG breakout (Ï∂îÏÑ∏ Î∞©Ìñ•, ÏâΩÍ≤å ÏßÑÏûÖ)
  ///   - Condition: currentPrice > resistance * 1.001 (0.1% ÎèåÌåå)
  /// - RSI > 75: SHORT breakdown (Ïó≠Ï∂îÏÑ∏, ÏóÑÍ≤©ÌïòÍ≤å ÏßÑÏûÖ)
  ///   - Condition: currentPrice < support * 0.995 (0.5% Ïù¥ÌÉà)
  ///
  /// Extreme Bearish Market (Í∞ïÌïú ÌïòÎùΩ Î™®Î©òÌÖÄ):
  /// - RSI >= 50: SHORT breakdown (Ï∂îÏÑ∏ Î∞©Ìñ•, ÏâΩÍ≤å ÏßÑÏûÖ)
  ///   - Condition: currentPrice < support * 0.999 (0.1% Ïù¥ÌÉà)
  ///   - ‚≠ê RSI < 50ÏùÄ Ïù¥ÎØ∏ Í≥ºÎß§ÎèÑ Íµ¨Í∞Ñ ‚Üí Í∏âÎùΩ ÌõÑÎ∞ò ‚Üí SHORT Í∏àÏßÄ
  /// - RSI < 30: LONG breakout (Ïó≠Ï∂îÏÑ∏, ÏóÑÍ≤©ÌïòÍ≤å ÏßÑÏûÖ)
  ///   - Condition: currentPrice > resistance * 1.005 (0.5% ÎèåÌåå)
  ///
  /// Other market conditions: Breakout strategy disabled
  static TradingSignal _analyzeBreakoutSignal({
    required MarketCondition condition,
    required List<double> closePrices,
    required double currentPrice,
    required StrategyConfig strategyConfig,
  }) {
    // Only activate in extreme markets
    if (condition != MarketCondition.extremeBullish &&
        condition != MarketCondition.extremeBearish) {
      return TradingSignal(
        type: SignalType.none,
        confidence: 0.0,
        reasoning: 'Î∏åÎ†àÏù¥ÌÅ¨ÏïÑÏõÉ Ï†ÑÎûµ ÎπÑÌôúÏÑ±Ìôî (Í∑πÎã®Ï†Å ÏãúÏû•Îßå ÌôúÏÑ±Ìôî)',
        strategyConfig: strategyConfig,
      );
    }

    if (closePrices.length < 30) {
      return TradingSignal(
        type: SignalType.none,
        confidence: 0.0,
        reasoning: 'Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±',
        strategyConfig: strategyConfig,
      );
    }

    // Calculate RSI
    final rsi = calculateRSISeries(closePrices, 14);
    if (rsi.isEmpty) {
      return TradingSignal(
        type: SignalType.none,
        confidence: 0.0,
        reasoning: 'RSI Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±',
        strategyConfig: strategyConfig,
      );
    }
    final currentRSI = rsi.last;

    // Calculate support and resistance from recent 20 candles (EXCLUDING current candle)
    final lookback = closePrices.length >= 21 ? 20 : closePrices.length - 1;
    if (lookback < 10) {
      return TradingSignal(
        type: SignalType.none,
        confidence: 0.0,
        reasoning: 'Î∏åÎ†àÏù¥ÌÅ¨ÏïÑÏõÉ Î∂ÑÏÑùÏö© Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±',
        strategyConfig: strategyConfig,
      );
    }
    final recentPrices = closePrices.sublist(closePrices.length - lookback - 1, closePrices.length - 1);

    final resistance = recentPrices.reduce((a, b) => a > b ? a : b); // ÏµúÍ≥†Ï†ê
    final support = recentPrices.reduce((a, b) => a < b ? a : b);    // ÏµúÏ†ÄÏ†ê

    Logger.debug('üíé Support/Resistance: \$${support.toStringAsFixed(2)} / \$${resistance.toStringAsFixed(2)}');
    Logger.debug('   Current: \$${currentPrice.toStringAsFixed(2)} | RSI: ${currentRSI.toStringAsFixed(1)}');

    // ========================================================================
    // EXTREME BULLISH MARKET (Í∑πÎã®Ï†Å ÏÉÅÏäπÏû•)
    // ========================================================================
    if (condition == MarketCondition.extremeBullish) {

      // RSI <= 75: LONG Î∏åÎ†àÏù¥ÌÅ¨ÏïÑÏõÉ (Ï∂îÏÑ∏ Î∞©Ìñ•, ÏâΩÍ≤å)
      if (currentRSI <= 75) {
        if (currentPrice > resistance * 1.001 && currentRSI > 50 && currentRSI <= 85) {
          final breakoutPercent = ((currentPrice - resistance) / resistance * 100);
          final confidence = 0.80 + (currentRSI - 50) / 100;

          Logger.debug('üöÄ LONG BREAKOUT: \$${currentPrice.toStringAsFixed(2)} > \$${resistance.toStringAsFixed(2)} (+${breakoutPercent.toStringAsFixed(2)}%)');

          return TradingSignal(
            type: SignalType.long,
            confidence: confidence.clamp(0.0, 1.0),
            reasoning: 'Ï†ÄÌï≠ÏÑ† ÎèåÌåå (Í∑πÎã®Ï†Å ÏÉÅÏäπ Î™®Î©òÌÖÄ, RSI: ${currentRSI.toStringAsFixed(1)})',
            entryPrice: currentPrice,
            takeProfitPrice: currentPrice * (1 + strategyConfig.takeProfitPercent),
            stopLossPrice: currentPrice * (1 - strategyConfig.stopLossPercent),
            strategyConfig: strategyConfig,
          );
        }
      }

      // RSI > 75: SHORT Î∏åÎ†àÏù¥ÌÅ¨Îã§Ïö¥ (Ïó≠Ï∂îÏÑ∏, ÏóÑÍ≤©)
      else {
        if (currentPrice < support * 0.995 && currentRSI > 75 && currentRSI < 90) {
          final breakdownPercent = ((support - currentPrice) / support * 100);
          final confidence = 0.65 + (currentRSI - 75) / 100;

          Logger.debug('üìâ SHORT BREAKDOWN (Ïó≠Ï∂îÏÑ∏): \$${currentPrice.toStringAsFixed(2)} < \$${support.toStringAsFixed(2)} (-${breakdownPercent.toStringAsFixed(2)}%)');

          return TradingSignal(
            type: SignalType.short,
            confidence: confidence.clamp(0.0, 1.0),
            reasoning: 'Í≥ºÎß§Ïàò Íµ¨Í∞Ñ ÏßÄÏßÄÏÑ† Ïù¥ÌÉà (Î∞òÏ†Ñ Ïã†Ìò∏, RSI: ${currentRSI.toStringAsFixed(1)})',
            entryPrice: currentPrice,
            takeProfitPrice: currentPrice * (1 - strategyConfig.takeProfitPercent),
            stopLossPrice: currentPrice * (1 + strategyConfig.stopLossPercent),
            strategyConfig: strategyConfig,
          );
        }
      }
    }

    // ========================================================================
    // EXTREME BEARISH MARKET (Í∑πÎã®Ï†Å ÌïòÎùΩÏû•)
    // ========================================================================
    else if (condition == MarketCondition.extremeBearish) {

      // RSI >= 50: SHORT Î∏åÎ†àÏù¥ÌÅ¨Îã§Ïö¥ (Ï∂îÏÑ∏ Î∞©Ìñ•, ÏâΩÍ≤å)
      // ‚≠ê ÌïµÏã¨: RSI < 50ÏùÄ Ïù¥ÎØ∏ Í≥ºÎß§ÎèÑ ‚Üí Í∏âÎùΩ ÌõÑÎ∞ò ‚Üí SHORT Í∏àÏßÄ
      if (currentRSI >= 50) {
        if (currentPrice < support * 0.999 && currentRSI >= 50 && currentRSI < 75) {
          final breakdownPercent = ((support - currentPrice) / support * 100);
          final confidence = 0.80 + (75 - currentRSI) / 100;

          Logger.debug('üìâ SHORT BREAKDOWN: \$${currentPrice.toStringAsFixed(2)} < \$${support.toStringAsFixed(2)} (-${breakdownPercent.toStringAsFixed(2)}%)');

          return TradingSignal(
            type: SignalType.short,
            confidence: confidence.clamp(0.0, 1.0),
            reasoning: 'ÏßÄÏßÄÏÑ† Ïù¥ÌÉà (Í∑πÎã®Ï†Å ÌïòÎùΩ Î™®Î©òÌÖÄ, RSI: ${currentRSI.toStringAsFixed(1)})',
            entryPrice: currentPrice,
            takeProfitPrice: currentPrice * (1 - strategyConfig.takeProfitPercent),
            stopLossPrice: currentPrice * (1 + strategyConfig.stopLossPercent),
            strategyConfig: strategyConfig,
          );
        }
      }

      // RSI < 30: LONG Î∏åÎ†àÏù¥ÌÅ¨ÏïÑÏõÉ (Ïó≠Ï∂îÏÑ∏, ÏóÑÍ≤©)
      else if (currentRSI < 30) {
        if (currentPrice > resistance * 1.005 && currentRSI >= 15 && currentRSI < 30) {
          final breakoutPercent = ((currentPrice - resistance) / resistance * 100);
          final confidence = 0.65 + (30 - currentRSI) / 100;

          Logger.debug('üöÄ LONG BREAKOUT (Ïó≠Ï∂îÏÑ∏): \$${currentPrice.toStringAsFixed(2)} > \$${resistance.toStringAsFixed(2)} (+${breakoutPercent.toStringAsFixed(2)}%)');

          return TradingSignal(
            type: SignalType.long,
            confidence: confidence.clamp(0.0, 1.0),
            reasoning: 'Í≥ºÎß§ÎèÑ Íµ¨Í∞Ñ Ï†ÄÌï≠ÏÑ† ÎèåÌåå (Î∞òÎì± Ïã†Ìò∏, RSI: ${currentRSI.toStringAsFixed(1)})',
            entryPrice: currentPrice,
            takeProfitPrice: currentPrice * (1 + strategyConfig.takeProfitPercent),
            stopLossPrice: currentPrice * (1 - strategyConfig.stopLossPercent),
            strategyConfig: strategyConfig,
          );
        }
      }
    }

    // No breakout signal
    return TradingSignal(
      type: SignalType.none,
      confidence: 0.0,
      reasoning: 'Î∏åÎ†àÏù¥ÌÅ¨ÏïÑÏõÉ ÎåÄÍ∏∞ Ï§ë',
      strategyConfig: strategyConfig,
    );
  }
}
